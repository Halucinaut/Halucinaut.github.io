{{ define "main" }}
{{ if .Title }}
<header class="page-header">
  {{ partial "breadcrumbs.html" . }}
  <h1>{{ .Title }}</h1>
  {{ if .Description }}
  <div class="post-description">
    {{ .Description }}
  </div>
  {{ end }}
</header>
{{ end }}

<div class="projects-list">
{{ range .Pages }}
{{ if not .Params.parent_project }}
<article class="post-entry project-card">
  <a href="{{ .RelPermalink }}" class="card-link">
    {{ if .Params.cover.image }}
    <figure class="entry-cover">
      <img loading="lazy" src="{{ .Params.cover.image | absURL }}" alt="{{ .Params.cover.alt }}" />
    </figure>
    {{ end }}
    <div class="card-body">
      <header class="entry-header">
        <h2>{{ .Title }}</h2>
      </header>
      {{ if .Summary }}
      <p class="card-summary">{{ .Summary }}</p>
      {{ end }}
      {{ if .Params.tags }}
      <div class="card-tags">
        {{ range .Params.tags }}
        <span class="tag">{{ . }}</span>
        {{ end }}
      </div>
      {{ end }}
      <div class="card-footer">
        <span class="post-date">{{ .Date.Format "01-02" }}</span>
        <span class="giscus-reactions" data-path="{{ .RelPermalink }}">ğŸ‘ 0</span>
      </div>
    </div>
  </a>
</article>
{{ end }}
{{ end }}
</div>

{{ if gt .Paginator.TotalPages 1 }}
<footer class="page-footer">
  <nav class="pagination">
    {{ if .Paginator.HasPrev }}
    <a class="prev" href="{{ .Paginator.Prev.URL | absURL }}">â† {{ i18n "prev_page" }}</a>
    {{ end }}
    {{ if .Paginator.HasNext }}
    <a class="next" href="{{ .Paginator.Next.URL | absURL }}">{{ i18n "next_page" }} â†’</a>
    {{ end }}
  </nav>
</footer>
{{ end }}

<script>
// æ£€æµ‹æ ‡é¢˜æ˜¯å¦è¶…å‡ºå®¹å™¨å®½åº¦ï¼Œè¶…å‡ºåˆ™æ·»åŠ  data-overflow å±æ€§
document.addEventListener('DOMContentLoaded', function() {
    const titles = document.querySelectorAll('.projects-list .project-card .entry-header h2');
    titles.forEach(function(title) {
        const container = title.parentElement;
        if (title.scrollWidth > container.clientWidth) {
            title.setAttribute('data-overflow', 'true');
        }
    });
});

// ä» Giscus è·å–ååº”æ•°
async function fetchGiscusReactions() {
    const repo = 'Halucinaut/Halucinaut.github.io';
    const category = 'Announcements';
    const reactionElements = document.querySelectorAll('.giscus-reactions');
    
    try {
        // è·å– Discussions åˆ—è¡¨
        const response = await fetch(`https://api.github.com/repos/${repo}/discussions?per_page=100`);
        if (!response.ok) throw new Error('Failed to fetch discussions');
        
        const discussions = await response.json();
        
        reactionElements.forEach(function(el) {
            const path = el.getAttribute('data-path');
            // æŸ¥æ‰¾åŒ¹é…çš„ discussionï¼ˆæ ¹æ®æ ‡é¢˜æˆ– body ä¸­çš„è·¯å¾„ï¼‰
            const discussion = discussions.find(function(d) {
                return d.body && d.body.includes(path);
            });
            
            if (discussion && discussion.reactions) {
                const total = discussion.reactions.total_count;
                if (total > 0) {
                    el.textContent = 'ğŸ‘ ' + total;
                }
            }
        });
    } catch (error) {
        console.log('Giscus reactions fetch failed:', error);
    }
}

// é¡µé¢åŠ è½½åè·å–ååº”æ•°
fetchGiscusReactions();
</script>
{{ end }}
